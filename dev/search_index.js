var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = LumberjackToolkit","category":"page"},{"location":"#LumberjackToolkit","page":"Home","title":"LumberjackToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for LumberjackToolkit.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [LumberjackToolkit]","category":"page"},{"location":"#LumberjackToolkit._correct_center-Tuple{Vector{Float64}, Float64}","page":"Home","title":"LumberjackToolkit._correct_center","text":"_correct_center(bins::Vector{Float64}, reference::Float64)\n\nIt corrects the bin values based on the referenced center. In this way, the center will become zero and all the bins values will be reajusted to apply it. Now, every distance is compared with the central value.\n\nArguments\n\nbins::Vector{Float64}: a Vector{Float64} with the bins.\nreference::Float64: a Float64 with the reference center.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit._correct_symmetry-Tuple{Vector{Float64}, Float64}","page":"Home","title":"LumberjackToolkit._correct_symmetry","text":"_correct_symmetry(bins::Vector{Float64}, reference::Float64)\n\nDo the same thing that _correct_center(...), but it extends the concept to adjust the data in such way that the center will become the center of the box in every frame.\n\nArguments\n\nbins::Vector{Float64}: a Vector{Float64} with the bins.\nreference::Float64: a Float64 with the reference center.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit._get_reference-Tuple{MolSimToolkit.Simulation, String}","page":"Home","title":"LumberjackToolkit._get_reference","text":"_get_reference(simulation::MolSimToolkit.Simulation, selection::String)\n\nIt aims to get the reference center for each frame along the trajectory.\n\nArguments\n\nsimulation::MolSimToolkit.Simulation: a MolSimToolkit.Simulation object.\nselection::String: a selection string to get the reference center. For exemple, \"all\" or \"not water\".\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit._ordering_symmetry-Tuple{Vector{Float64}, Vector{Float64}}","page":"Home","title":"LumberjackToolkit._ordering_symmetry","text":"_ordering_symmetry(bins::Vector{Float64}, ρ::Vector{Float64})\n\nThis function checks if the bins are ordered after the symmetry protocol and if not, it orders them.\n\nArguments\n\nbins::Vector{Float64}: a Vector{Float64} with the bins.\nρ::Vector{Float64}: a Vector{Float64} with the densities.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.align_trajectory-Tuple{String, String, String}","page":"Home","title":"LumberjackToolkit.align_trajectory","text":"align_trajectory(psfname::String, pdbname::String, trajectory::String; ...)\n\nAligns a trajectory to a reference structure using VMD. It loads the psf, pdb, and trajectory files, wraps the trajectory, and aligns the frames to the reference structure.     The selection argument is used to define the atoms to be aligned based on the VMD selection, such as a protein or a cellulose fibril.     The DebugVMD argument equals  true will return  the VMD output. The function returns the path to the new trajectory.     If the new_trajectory argument is not provided, a temporary file is created.\n\nArguments\n\npsfname::String: The path to the PSF file.\npdbname::String: The path to the PDB file.\ntrajectory::String: The path to the trajectory file.\nselection::String: The VMD selection to be aligned. Default is \"protein\".\npbc_dimensions::String: The PBC dimensions to be set on pbctools format. If not provided, the function will try to read the dimensions from the .xsc file, based on the location of trajectory.\nnew_trajectory::String: The path to the new trajectory file. If not provided, a temporary file is created.\nreference::Int: The frame to be used as reference. Default is 0, the initial frame.\nvmd::String: The path to the VMD executable. Default is \"vmd\".\nDebugVMD::Bool: If true, the function will return the VMD output. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.average_bins-Tuple{Vector{Float64}}","page":"Home","title":"LumberjackToolkit.average_bins","text":"average_bins(bins::Vector{Float64})\n\nIt takes an average vector based on the binned box parameters. So it can be rightly compare with the ρ density with length(density)  length(bins) - 1.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.averaging_profile-Tuple{Vector{Vector{Float64}}, Vector{Vector{Float64}}}","page":"Home","title":"LumberjackToolkit.averaging_profile","text":"averaging_profile(distances::Vector{Vector{Float64}}, densities::Vector{Vector{Float64}})\n\nThis function takes the distances and densities from Vector{Vector{Float64}} to Vector{Float64} by means and standard deviation computations.\n\nArguments\n\ndistances::Vector{Vector{Float64}}: a Vector{Vector{Float64}} with the distances from the center of the profile.\ndensities::Vector{Vector{Float64}}: a Vector{Vector{Float64}} with the densities of the profile.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.binning-Tuple{MolSimToolkit.Simulation}","page":"Home","title":"LumberjackToolkit.binning","text":"binning(simulation::MolSimToolkit.Simulation; axis=\"z\", resolution=1.)\n\nIt reports the bins and normalization factor for the loaded simulation box.\n\nArguments\n\nsimulation::MolSimToolkit.Simulation: a MolSimToolkit.Simulation object.\naxis::String: a String with the axis flag.\ndimensions::Int: an integer with the number of dimensions. It can be 1 or 2.\nresolution::Float64: a Float64 with the resolution of the bins.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.densityprofile-Tuple{String, String}","page":"Home","title":"LumberjackToolkit.densityprofile","text":"densityprofile(pdb::String, trajectory::String; ...)\n\nIt computes the density profile for each one of the frames inside the trajectory.\n\nArguments\n\npdb::String: a String with the pdb file path.\ntrajectory::String: a String with the trajectory file path.\nprofile::String: a String with the profile type. It can be \"number\", \"mass\", \"charge\", or \"electron\".\nselection::String: a String with the selection of the atoms.\naxis::String: a String with the axis flag.\ndimensions::Int: an integer with the number of dimensions. It can be 1 or 2.\nresolution::Float64: a Float64 with the resolution of the bins.\ncenter::Bool: a Bool to center the profile.\nsymmetry::Bool: a Bool to apply the symmetry protocol.\nsymmetry_selection::String: a String with the selection of the atoms to apply the symmetry protocol.\nfirst::Int: an integer with the first frame to be considered.\nstep::Int: an integer with the step to be considered.\nlast::Int: an integer with the last frame to be considered.\ncharge_column::String: a String with the charge column to be considered.\nedp::String: a String with the electron density profile.\ncharge_correction::Bool: a Bool to apply the charge correction.\nnormalization::Bool: a Bool to apply the normalization.\necho::Bool: a Bool to print or not the output.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.dihedral-NTuple{4, StaticArraysCore.SVector}","page":"Home","title":"LumberjackToolkit.dihedral","text":"dihedral(atom1::StaticArrays.SVector, atom2::StaticArrays.SVector, atom3::StaticArrays.SVector, atom4::StaticArrays.SVector)\n\nCalculate the dihedral angle between four atoms. The dihedral angle is the angle between the planes defined by the atoms (atom1, atom2, atom3) and (atom2, atom3, atom4). The dihedral angle is calculated using the atan method.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.dihedrals-Tuple{String, String, String}","page":"Home","title":"LumberjackToolkit.dihedrals","text":"dihedrals(pdbname::String, trajectory::String, segname::String; ...)\n\nCalculate the dihedral angles and their sum based on the carbohydrate chain. The pdbname carries the atom information, and the trajectory holds the coordinates for each atoms in the simulation. The carbohydrate chain is defined by the segname parameter, that is the same segname present on PDB.\n\nWohlert uses a lot the ϕ(O5'-C1'-O4-C4) and ψ(C1'-O4-C4-C3) definition, while Carol uses ϕ(O5'-C1'-O4-C4) and ψ(C1'-O4-C4-C5)\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.dispm-Tuple{Vector{<:Vector{StaticArraysCore.SVector{3, Float64}}}}","page":"Home","title":"LumberjackToolkit.dispm","text":"dispm(frames::Vector{<:Vector{SVector{3, Float64}}}, weights::Vector{Float64}; weight_method=nothing)\n\nCalculate the displacement matrix of a trajectory with weights.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.lovo_mapping-Tuple{String, String}","page":"Home","title":"LumberjackToolkit.lovo_mapping","text":"map_fractions(atoms::AbstractVector{<:PDBTools.Atom}, trajectory_file::String)\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.msd2-Tuple{Vector{Vector{StaticArraysCore.SVector{3, Float64}}}}","page":"Home","title":"LumberjackToolkit.msd2","text":"msd(trajectory::Vector{Vector{SVector{3, Float64}}}; step=1, dim=collect(1:3))\n\nCalculate the mean square displacement (MSD) of a trajectory. The MSD is calculated using Green-Kubo relation: <r²(t)> = MSD(t) = 1/N * Σ <[r_i(t) - r_i(0)]²>. It is important to notice that trajectories must have been adjusted to approach:\n\n    traj = [\n                [coord(t1), coord(t2), coord(t3), ..., coord(tmax)],    ## molecule 1\n                [coord(t1), coord(t2), coord(t3), ..., coord(tmax)],    ## molecule 2\n                [coord(t1), coord(t2), coord(t3), ..., coord(tmax)],    ## molecule 3\n                ...\n                [coord(t1), coord(t2), coord(t3), ..., coord(tmax)],    ## molecule N\n        ]\n\nArguments\n\ntrajectory::Vector{Vector{SVector{3, Float64}}}: A vector of vectors of 3D coordinates.\nstep::Int=1: The time step to calculate the MSD.\ndim::Vector{Int}=collect(1:3): The dimensions to calculate the MSD.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.r_avg-Tuple{Vector{<:Vector{StaticArraysCore.SVector{3, Float64}}}}","page":"Home","title":"LumberjackToolkit.r_avg","text":"r_avg(frames::Vector{<:Vector{SVector{3, Float64}}})\n\nCalculate the average position of each atom inside the trajectory.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.readcoords-Tuple{AbstractVector{<:PDBTools.Atom}, String}","page":"Home","title":"LumberjackToolkit.readcoords","text":"readcoords(atoms::AbstractVector{<:PDBTools.Atom}, pdbname::String)\n\nRead the coordinates of a trajectory in a PDB file. Returns a vector of vectors of coordinates of selected atoms.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.select_atoms-Tuple{Vector{PDBTools.Atom}, String, String, Int64, String}","page":"Home","title":"LumberjackToolkit.select_atoms","text":"select_atoms(atom::Vector{PDBTools.Atom}, name::String, resname::String, resnum::Int64, segname::String)\n\nSelect the atoms that match the given name, residue name, residue number, and segment name.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.simsteps-Tuple{Float64, Float64}","page":"Home","title":"LumberjackToolkit.simsteps","text":"\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.simulation_steps-Tuple{Int64}","page":"Home","title":"LumberjackToolkit.simulation_steps","text":"simulation_steps(t_simulation::Int64; unit=\"ns\", timestep=2.0, output=1000)\n\nThis function calculates the number of steps you need to set and the number of frames that you will get in the MD simulation.\n\nArguments\n\nt_simulation: The total simulation time in the specified unit.\nunit: The unit of the simulation time. It can be \"ns\" (nan\ntimestep: The time step of the simulation in the specified unit.\noutput: The frequency of frame storage during the MD simulation.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.vmd_get_charges-Tuple{String, String}","page":"Home","title":"LumberjackToolkit.vmd_get_charges","text":"vmd_get_charges(psf::String, pdb::String; newpdb=nothing, pdb_column=\"beta\", vmd=\"vmd\")\n\nUses VMD to catch the charges inside the PSF file and transfer it to PDB file on b-factor or occupancy columns. Notice that you need VMD installed to run this code. Check it on: https://www.ks.uiuc.edu/Development/Download/download.cgi?PackageName=VMD.\n\nArguments\n\npsf::String and pdb::String: the name of the raw files.\nnewpdb::String: the name of the new PDB file with the charges. The default is nothing and it will generate a PDB on your temporary files.\npdb_column::String: the column to store the charges. The default is beta.\nvmd::String: the VMD executable. The default is vmd.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.write_frame!-Tuple{IO, AbstractVector{<:PDBTools.Atom}, Chemfiles.Frame}","page":"Home","title":"LumberjackToolkit.write_frame!","text":"write_frame!(trajectory_pdb_file, atoms, frame\n\nWrite a frame of a trajectory in the temporary PDB trajectory file.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.writepdb_trajectory-Tuple{String, String}","page":"Home","title":"LumberjackToolkit.writepdb_trajectory","text":"writepdb_trajectory(pdbname::String, trajectory::String; selection=\"all\", first=1, last=nothing, step=1)\n\nWrite a trajectory in a temporary PDB file. This is very useful when you want to visualize the edited trajectory in VMD. The MDLovoFit program uses this function to write the trajectory in a PDB file before the analysis.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.δ-Tuple{Float64, Float64, Float64}","page":"Home","title":"LumberjackToolkit.δ","text":"δ(value::Float64, lower::Float64, upper::Float64)\n\nIt is an indicator function that maps the elements inside x_lower  x_value  x_upper interval.\n\n\n\n\n\n","category":"method"},{"location":"#LumberjackToolkit.ρ-Tuple{Vector{Float64}, Vector{MolSimToolkit.Point3D{Float64}}, Float64}","page":"Home","title":"LumberjackToolkit.ρ","text":"ρ(bins::Vector{Float64}, positions::Vector{Point3D{Float64}}, N::Float64; axis=\"z\", prop=nothing)\n\nComputes the density for each bin interval given the frame positions. Here, we apply a normalization base on the bin dimensions, so all the frames will have the same sum(ρ). The prop argument is used to compute the density of a specific property, like the atomic number, mass, or charge.\n\nArguments\n\nbins::Vector{Float64}: a Vector{Float64} with the bin intervals.\npositions::Vector{Point3D{Float64}}: a Vector{Point3D{Float64}} with the atomic positions.\nN::Float64: a Float64 with the normalization factor.\naxis::String: a String with the axis flag.\nprop::Vector{Float64}: a Vector{Float64} with the property to be computed.\n\n\n\n\n\n","category":"method"}]
}
